---
title: "5分钟学会如何做一个掌握高效测试的运维开发者"
date: 2019-06-24T19:07:26+08:00
draft: false
---

阅读时间：约5分钟

![](/img/5-minute-devops-effective-testing/developer-3461405_640.png)

## 保护业务
开发人员驱动的软件测试并不是什么新鲜事物。研究表明，高绩效的组织团队依赖于开发人员编写的测试，而不是依赖“测试自动化人员”等外部团队。许多开发商提供所谓的“成熟测试工具”并承诺让开发团队从测试中解脱出来。我已经看到了很多类似工具的演示demo，这些工具使用平滑的UI工具控制，旨在让那些有预算控制的人眼花缭乱，他们承诺使测试变得简单，即使不了解业务的外部承包商也能做到。 这些工具声称只有单元测试才是开发团队的责任。我甚至听说开发人员的生产力测试应该给测试团队，因为“开发人员有更好的事情要做，而且没有资格进行测试”。 哇！

这些误导人的暗示使企业面临风险。除了结果之外，客户并不关心任何事情，而来自DevOps开发原则和CI/CD实践应该可以产生更好的结果。工具无法解决这个问题。熟练的，专业的开发人员应使用有效的工具。

## 持续集成/持续部署 == 测试
对于任何希望掌握CI/CD的人来说，没有什么比有效使用测试更重要了。

持续部署管道的整个要点是安全地持续为最终用户提供价值。代码必须向管道证明它是值得交付的，管道的工作是防止交付，除非证明其价值并尽可能快。要实现这一点，产品团队应注意以下优先顺序：  
1. 构建并强化CD管道。
2. 管道保持健康。如果构建中断，请丢弃所有内容并进行修复。如果你不能成功构建，意味着你之前做的没有意义。确保你的修改可以按需构建成功，从而避免大家都不愿看到的应急修复。
3. 当（不是如果）发现缺陷时，通过为该缺陷设计额外的有效测试来进一步硬化管道。
4. 编写代码并每日交付从而连续不断地测试我们修复产品的能力，缩短最小平均修复时间。
5. 尽可能快的获得每次修改后的状态反馈。

CI/CD不是工具。如果你要执行CD进程，那么以下是正确的。

* 在版本控制中提交代码之前，实现并验证所有代码更改的测试。测试驱动开发是个好主意。开发期间的测试是不可协商的。
* 对于任何代码更改，都只有一条生产路径，不管它有多重要。我们总是使用我们的紧急程序，我们总是用同样的方法测试。
* 测试版本也加入。
* 紧急情况下，不能停用测试。
* 虽然可能有一个按钮来推动交付到生产环境，但一旦代码通过代码审查，就没有其他方式手动操作、人工干预或向外部团队移交。

如果不符合上述情况，那么你编写的Jenkins脚本无论多好以及你为测试团队话费了多少费用将没有任何意义。你将永远无法提升可持续交付的质量，并且您将在每次变更时冒着风险，特别是在紧急情况下。

持续交付的秘诀是保持正确的心态：它总是紧急的。我们设计交付管道，以标准化工作并移除手动干预的地方，是因为在凌晨3点，当生产环境发生紧急情况时，VP正呼吸急促，我们正依靠咖啡和焦急状态下工作，我们不想忘记我们有热修复的处理方式。我们依然应该保持标准流程。因为这已经是一场噩梦了，所以让我们不要因为改变而变得更糟，好吗？

以上所有这些都对我们如何设计测试计划有影响。

## 制定弹性测试计划
你的测试流程需要加强对抗现实混乱场景的能力。在一个幻想的测试世界中，网络从不具有延迟，外部依赖始终保持稳定，并且拥有这些依赖关系的团队永远不会在没有版本控制的情况下部署重大的API更改。可以假设一切都会完美运行，直到它出现紧急情况并且你的假设被遗憾地弄错了。 你必须相信你的测试。 您不能接受测试中的随机故障。 即使您周围的一切都在崩溃，您的关键路径管道测试也必须正常工作。

### 基础单元测试必不可少
单元测试绝对是基础。可往往这也是大多数开发人员停止的地方。虽然单元测试至关重要，但它们需要用于正确的目的；对复杂，孤立的代码单元进行黑盒测试。通常，我们在讨论的是这个级别的类，方法或函数。为了构建持续交付测试流程，我们希望它快速高效。我们希望针对风险行为进行测试。100％的代码覆盖率既不合理也不高效。测试getter和setter方法之类的东西是没有用的，除非他们正在做一些有趣的事情。如果我们不开发JVM，那么测试Java将数据分配给变量的能力是无用的。有很多库中都有关于单元测试的模式和反模式的良好信息。最受欢迎的是xUnit Test Patterns。这是一部关于正确测试和常见反模式的巨著，我强烈推荐。

### 实现业务目标：功能测试
单元测试可以很好地了解各个单元将如何执行，但大多数应用程序正在实现一些业务流。测试核心业务逻辑是关键的，而单元测试在这方面是无效的。许多团队会立即跳到端到端测试来解决这一问题，但这并不稳定，无法有效地测试所有的逻辑分支。  

更好的方法是使用独立测试每个业务特性的功能测试。

```
“假设我在银行里有20英镑。
当我向收银机要20英镑时
那么它应该给我20英镑。
然后从我的账户中扣除。”

摘自：利兹·基奥。“行为驱动开发。”
```

这里我们有一个单一的业务特性，可以由一个帐户服务实现。这不需要特殊的工具来实现，只需要“我需要测试这个流程”的思想过程。就像一个好的单元测试一样，每个功能测试都应该是集中的，能够并行运行，并且不应该直接集成在测试范围之外。

### API契约测试
通信接口是大多数缺陷发生的地方。很明显，在实现这些接口背后的行为之前，我们应该优先测试这些接口。这就是契约测试和契约驱动开发变得重要的地方。

记录API契约有很多糟糕的方法，但只有一种正确的方法：由数据提供者记录和测试的契约测试和契约模拟。契约测试的基本形式是对契约约定数据的简单单元测试。

下面是一个简单的例子：
```
it('it should return all the teams', done => {
    /*
    Here we'll use the Sinon mocking library to have the response mocked with our 
    JSON payoad fixture file that we provide to our consumers for them to test aginst
    so that we are both testing with the same structure.
    */
    chai.request(app)
        .get('/v1/teams')
        .end((err, res) => {
          if (err) done(err)

          /*
          * Fail fzst if the basic structure and response code aren't correct.
          */
          expect(res).to.haveOwnProperty('status')
          expect(res).to.haveOwnProperty('body')
          expect(res.status).to.equal(200)
          expect(res.body).to.be.an('array')
          expect(res.body.length).to.be.greaterThan(0)

          /*
          * Check for the REQUIRED properties. Optional properties may also be there, 
          * but we don't test for them in the general case, only when they matter.
          */
          expect(res.body[0]).to.haveOwnProperty('id')
          expect(res.body[0]).to.haveOwnProperty('teamId')
          expect(res.body[0]).to.haveOwnProperty('teamName')
          expect(res.body[0]).to.haveOwnProperty('scoreEntries')
          expect(res.body[0].scoreEntries.length).to.be.greaterThan(0)

          done()
        })
    )
    .catch(err => {
      done(err)
    })
})
```

### 与他人相处融洽：集成测试
契约测试在CI构建期间为你建立了一定程度的信心，即你没有破坏契约或在消费使用阶段破坏契约，但由于它们是被模拟的，因此它们需要另一层测试来验证模拟。

所谓“集成测试”是指测试通过几个组件的业务流和端到端测试的活动。其他和我上面提到的功能测试类似。在下面我提到的参考中，他们将集成测试称为验证组件之间通信路径的行为；对于依赖应用的消费者经常会问到，“我能理解来自我的依赖性的响应吗？”测试不应试图测试依赖关系的行为，只应测试响应是可以理解的。

集成测试有一个不足，CD管道架构师需要理解：它们是片状的。你不能保证当CD流执行时依赖项将可用。如果这种依赖性不可用，你的团队仍有责任修复。记住上面CD的规则。不允许绕过要传递的测试。所以，如果遇到有冲突。我们如何设计解决方案？

**步骤1**：服务虚拟化。使用[wiremock](http://wiremock.org/)、[mountebank](http://www.mbtest.org/)或其他相关工具，我们可以进行虚拟集成。这些工具可以作为实际依赖项的代理，而[更好的工具](http://www.mbtest.org/)可以复制延迟并处理的不仅仅是HTTP。此外，除了最简单的集成测试外，它们还减少了对测试数据管理的需求。数据是测试中最难处理的东西，所以要避免它。

**步骤2**：有计划的集成测试。当需要直接集成测试时，按照标准流程之外的计划运行它。建立警报以告知您何时中断，并跟踪中断的原因。如果依赖关系不稳定，请跟踪如何快速检测它们的不稳定与它们所做的破坏性更改或需要解决的虚拟集成测试的问题。

使用此方法，您可以减少典型集成测试的许多脆弱环节，以及重复和快速地测试复杂场景，这些场景不能用不太精细的方法进行有效测试。

### 验证用户行为：端到端测试
跨多个组件的信息流和行为的端到端测试。当心出售数据记录和重放测试工具的供应商，这些工具声称通过这种方式简单地测试整个系统来减轻开发人员的负担。但是…

```
“基于记录测试的主要问题是它们记录的粒度级别。大多数商业工具都在用户界面（UI）元素级别记录操作，这会导致脆弱的测试。”
摘录自：杰拉德·梅萨罗斯。--XUnit测试模式：重构测试代码
```

端到端测试不能代替[适当分层的测试](http://xunitpatterns.com/Layer%20Test.html)。它们缺乏有效测试所需的粒度和数据控制。适当的端到端测试将集中在几个常用的路径流上，以验证用户在应用程序中的流转。将端到端的范围扩展到其他测试层以更好地覆盖测试范围会导致测试缓慢和不可靠。如果责任移交给外部测试团队，情况会更糟。

### 哪些是我们没有测试到的？
探索性测试是为了发现我们没有想到要测试的东西。我们永远不会想到每件事，所以团队中有擅长打破事物的人不断尝试打破事物，这样就可以增加对这些未知情况的测试，这一点很重要。是的，这是手工探索，但不是验收测试。如果你这时使用验收测试表，你就错了。

### 它真的能稳定运行吗？
负载测试和性能测试不应该是最后的事情。你应该站起来不断地执行它们。没有什么比相信一切都好，然后当有人试图使用它时失败更糟糕的了。操作稳定性是你应该考虑的第一个特性，而不是事后诸葛亮。

### 熵增发生
* 如果关键依赖项不可用怎么办？
* 如果收到很多推送垃圾怎么办？
* 云提供商重新启动以进行升级或是中断了怎么办？
* 延迟过大怎么办？
* 破坏性事件发生时怎么办？

世界是一个混乱的地方。弹性测试验证了您是否能够以最好的方式处理混乱。设计服务的优雅降级策略，然后测试它。

## 测试不是个简单的事情！
正确的测试需要正确的心态和至少与生产代码一样多的设计。它需要一个好奇的，经常思考“如果”的，有时甚至是邪恶的，头脑和思考能力。好的测试工程师不会仅仅构建测试代码，他们会帮助您更好地进行测试。测试应该快速、高效，并且应该完全记录应用程序的行为，因为测试是唯一可靠的文档。如果你对自己测试每一层的能力没有信心，就去研究它。延迟交货不是额外的。这就是工作。

如果你是一个专业的开发人员，这里有更多关于深入学习的参考资料：

* [加速：精益软件和DevOps的科学：构建和扩展高性能技术组织](https://itrevolution.com/book/accelerate/)
* [持续交付](https://continuousdelivery.com/)
* [实用测试金字塔](https://martinfowler.com/articles/practical-test-pyramid.html)
* [Xunit测试模式](https://www.oreilly.com/library/view/xunit-test-patterns/9780131495050/)
* [绘制软件弹性路径图](https://medium.com/walmartlabs/charting-a-path-to-software-resiliency-38148d956f4a)

翻译至：[https://medium.com/walmartlabs/5-minute-devops-effective-testing-bd38fab50564](https://medium.com/walmartlabs/5-minute-devops-effective-testing-bd38fab50564)
