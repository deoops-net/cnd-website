---
title: "你是什么垃圾？从现实角度看程序中的垃圾分类和回收"
date: 2019-07-15T10:36:31+08:00
draft: false
---

![](/img/gc_summary/top.jpg)

最近在上海生活的人们被垃圾分类搞得有些头大，有肉和没肉的小龙虾分别是什么垃圾？有柠檬片和没柠檬片的奶茶杯分别是什么垃圾？一不留神就要“掉坑”里。聪明的程序员们很快就做出了垃圾识别的小程序，甚至还催生了互联网上门收垃圾业务。

说到垃圾回收，程序员们很早就有接触，大部分的现代高级编程语言都自带可垃圾回收（GC/Garbage Collection）机制。

本文就以现实世界为参考来说说程序世界中的垃圾回收制度: 关于垃圾回收的一些相关概念和算法。

## 生命周期

说到垃圾，无论是现实世界还是数字世界，都有一个从产生到消亡的过程，一个物品如果完成了对自身价值，就会进入消亡的过程，也就产生了我们所说的垃圾（除非你喜欢用雪糕棍儿编花篮儿😁）。所以这里有一个我们要关注的概念就是这个过程：“**生命周期**”。

### 规律

**任何事物都存在一个生命周期**。比如一个冰淇淋，由机器和原料加工出来，然后会被人们吃掉，最终会被消化，这个过程几乎就大致的描述了冰淇淋的一生。我们一般会说：这样一个有规律和阶段性的周期就是生命周期。某些历史上的科学理论，我们常说的真理，也会随着时间的变化或是被推翻或是衍生成新的理论，所以它们也是有生命周期的。

电脑的开关机给操作系统的生命周期划了边界，同样的操作系统创建进程及销毁进程又给进程划分了生命周期的边界，又比如，我们的代码调用函数和返回也划分了函数的生命周期的边界。

> 所以我们一般认为的垃圾都是那些到生命周期最后阶段的事务。

### 规模和影响

**“规模和复杂性的增长会导致维护成本呈指数相关上升。”**

一个事物最终走到了终点，有些是我们不需要额外关注处理的，但是总会有一些会对当下造成不好的影响，比如像生活垃圾。这些不好的影响其实也是有一个前提的，就是**规模**，极端点的例子：如果你的城市每天只产生一吨的垃圾，那么对于城市的环保部门来说这个回收成本是极低的。但如果是成百上千甚至上万吨呢？

如果我们的代码永远是一个典型的`hello world`级别的程序，那么也就完全没必要发明什么GC算法了，因为在整个进程的生命周期中没有任何成规模的对象需要关注其生命周期所能产生的不良影响。但是，如果我们需要写一个大型的项目，其中可能有几十万行的代码甚至更多，按照这个方式演变，由于不同对象的不同生命周期所产生的资源消耗及占用迟早有一天会突破操作系统或者物理主机所能够提供资源的极限，这个时候我们就需要关注那些对象的生命周期了。我们需要在合理的可用资源空间内规划和使用我们创造出来的对象。

> 规模问题也是各种程序算法所要解决的最重要的问题。

## 垃圾种类

《上海市生活垃圾管理条例》要求民众按四大类：干垃圾，湿垃圾，可回收物，有害垃圾进行垃圾分类和投放。这里的种类还是比较宏观的，所以对于普通人就会闹出如开篇中的那些笑话出来。这里如果我们按常识排除法就可以比较简单的划分出来了，比如：

* 最先判断有害垃圾：一般来说就是工业**化学**制品类的，对环境有污染的，药品，电池这些。这些我们都比较好判断，如果不属于此种就接着往下判断。
* 是不是湿垃圾：湿垃圾也具有显著特征，基本上就是厨房里产生的生活垃圾，**剩饭剩菜**、**会腐化**这些。如果不属于此种我们就继续往下判断。
* 是不是可回收的垃圾：有过卖废品经验的人几乎不会犯错，但是大部分人还是知道**收废品**都会收些什么的，比如铜，铁等金属，塑料瓶，纸盒箱这些。一句话**能卖钱**的就是了（一些食堂饭店也会卖剩饭剩菜给养殖户，但是这明显不是可回收哦）。
* 如果**以上都不是**：那么一定是干垃圾了。

程序里我们也时常用上面的排除法来书写我们的业务逻辑，把一些否定条件用`if`前置如果符合就`return`退出，最后的留下的就是正常逻辑的进行。但这似乎是令一些关于如何更优雅写代码的话题了。

几乎所有的运行时（一些三方库提供了封装好的内存分配和回收机制，本文的runtime含义也包括这些库）提供的自动垃圾回收机制都是在处理内存“垃圾”，其目的是防止程序随着运行时间的增长而造成`OOM`。我们平时总讲的内存泄漏，就是因为未能及时回收程序申请的内存或者是一些异常情况导致的无法回收，随着时间增长而造成内存超限。那么操作系统就会觉得你这个进程坏掉了，就要“杀死”这个进程，也就是`OOM`。

不过程序中不只是有内存垃圾的，我们之前说了任何事物都有生命周期，而且随着生命周期的结束，如果对现有世界造成不好影响那么就可以把他归作垃圾。我们应该都遇到过这样的场景：创建一个子进程/线程去单独执行某些特殊任务。但是作为父进程如果只创建不回收，就会有一些隐患，一些子进程完成是会自动销毁的，但如果有一些异常情况可就说不准了。所以作为程序员的我们可不能片面的认为只有内存资源会产生垃圾，**计算或调度资源也会产生垃圾**。所以，你可能会想到我们自己写的或者用的三方的组件/模块也是有生命周期的，如果处理不当其实也会产生垃圾。

## 回收算法

“**程序世界的垃圾回收算法主要解决的是内存垃圾的问题**”

塑料废品可以重新融化、塑型并切割成塑料颗粒进行再加工。纸类也可以经过清洗，重制等工序变成新的纸张。得益于这种精细的垃圾分类，不但处理成本会极大降低，甚至可以产生新的价值，所以不要一味吐槽分类难，合理处理垃圾是一件很积德的事情呀！

上面提到的种种工序便是现实世界处理垃圾的“算法”了。而在程序世界，我们大部分时间了解的GC算法都是runtime处理内存回收的算法。

### 收集器

**引用计数收集器**

现实世界我们在小区摆好分类的垃圾桶，人们把垃圾按分类投放即可。

内存中我们也可以有简单的办法来模仿现实世界。有一个简单的实现叫**引用计数器**，引用计数顾名思义就是对于我们申请的内存按被”引用“次数进行计数（比如某个变量和内存空间的数据关联），每次新增关联计数器加一，反之减一。所以当某一块内存在程序世界没有相关的变量引用了，我们就可以把这块内存当做可已回收的“垃圾”了。

你可以想象一下，我们有一个超级大的整理箱，里面装满了各种废铜，废铁，费纸箱，然后有个管理人员拿着喇叭喊：“这个紫色的箱子还有人要了么？没人要**明天**收走了！”，第二天，管理人员拿着本子看紫色的箱子的备注是无人要，那么这个箱子就被车子拉走了，然后本子上另一个蓝色的箱子写小明要，管理员就先把蓝色的箱子留下了。这就是最简单的程序世界中最简单的垃圾收集的方法：如果一块内存没有相关引用了，那么未来某一时刻就可以被清理回收。

**追踪收集器**

小区里的人们啊有些懒，不太愿意来回登记这些垃圾，也不太愿意分类，所以现在有公司已经推出了上门收垃圾服务，过去收废品会给我们钱，现在我们需要花钱让别人帮我们收走垃圾，没办法，我们越来越懒了（其实是社会分工更精细化更高效了）。

程序世界显然不是因为懒，引用计数器方法虽然简单，但因为一些复杂情况会导致某一些内存无法被正常回收，一个常见的例子就是循环引用：因外部变量原因两块内存发生了相互引用，这就导致当外部变量不在引用自己的内存的时候，两个内存的计数器都是从二变成了一。没有什么外在方式可以让这两块内存的引用计数变成零，所以这两块内存也就永远没办法被回收了，也便产生了内存泄漏。

循环引用一个现实中的例子：在上面大整理箱的例子中，如果管理员在回收紫色箱子的时候发现里面有一个钥匙，钥匙旁边有个纸条说如果这把钥匙的锁不要了，那这个钥匙就不要了，然后在另一个蓝色的箱子里发现了一把锁说如果这把锁的钥匙不要了，那这个锁也不要了。虽然两个物品可以同时不要或者同时要，但是现在没有任何信息知道锁和钥匙的主要到底要还是不要，因为物品自己不能决定。这可难坏了管理员：）

所以聪明的程序员发明了另一个用来收集“垃圾”的办法，**追踪收集器**。

追踪收集器有点类似于管理员去小区的每家每户门口检查垃圾与户主进行记录确认，第二天收集人员拿着本子到每家每户门口把记录在本子上的垃圾收走，如果小明在管理员登记后又新扔了两个白箱子，那么第二天收集人员是不会收走这个箱子的。

程序的视角就是runtime会对程序所有的对象及子对象进行遍历检查，然后对有内存使用的进行标记，等在回收期把那些没有被标记的对象的内存回收掉。所以这个过程就变成了**对每个对象进行追踪**，而不是对每个“垃圾（内存引用）”进行追踪，也就不存在”垃圾引用垃圾”的问题了。

### 回收器

相对于垃圾收集/标记，如何更好的处理收集到的垃圾要更复杂一些，通常要考虑种种现实因素，每种不同的处理方法可能会根据现实情况做不同的取舍，比如：成本，时间等。

现实世界中，通常都是垃圾车来回收垃圾桶里的垃圾，这样很高效且易于执行。想象一下如果某小区有十个单元楼的垃圾桶已经满了，其余的单月楼都处于半满的状态。但是因为垃圾车的容量有限，单次可能只回收几只桶，为了在一个回收周期中尽可能让更多的单元楼可以继续投放垃圾，就需要一些策略了。我们不妨看看程序世界都引入了哪些策略来优化回收的问题。

程序世界中，各个语言的回收机制有接近的地方也有区别，都在根据不同的实际情况进行加权或者取舍。

* **标记-清除**：暂停一切工作（运行线程），用单独的线程扫描标记，清除，然后恢复运行。这种最简单直接的方法，缺少对内存的重新规划，所以会留下很多零零散散的空间，造成浪费。
* **标记-压缩**：和“标记-清除”类似，这个方法会将那些在用的空间“挪到”一起，剩下的空间就是连续的空间了。
* **复制**：这个方法也是对内存做优化的方法，通常先对内存做两个区域的划分，一半A用来正常分配使用，回收期会把这一半A中正在使用的空间挪到另一半B，之后B变成运行空间，A变为待用空间。
* **增量回收器**：这个方法是针对程序暂停的一种优化，对内存先划分若干区，程序申请时也会按区申请，这样在回收期间，可以针对某个区的使用情况来只暂停这个区的线程，其他区则不会受到影响。
* **分代**：分代主要是对“复制”法的一种优化。“复制”法的两个区域较大，所以整体的移动效率会受到一些因素的影响，比如对象的大小，存活时间等。分代针对这些影响因素对内存空间进行了分代（新/旧）划分。回收期多数发生在新代，这部分对象较小，且存活时间短。老代的回收周期要比新代大很多，所以这里放的都是存活久，体积大的对象。

## 总结

现代编程语言像java，javascript这些都是基于对象追踪（收集），分代（回收）所衍生的更优的GC算法。而且这些优化过的GC算法已经很难人肉感受到程序暂停，GC解决了很多底层语言的头脑负担，所以在开发效率上更具有优势。不过很多系统级的应用诸如Redis则不敢考虑用带GC的语言了。

PS:我们讨论算法的时候都要有规模前提的去看待

如果你对本文内容有任何问题欢迎来评论区讨论 ：）


## 参考文献

* [维基百科—-垃圾回收（计算机科学）](https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8))
* [上海市人民政府办公厅关于印发贯彻《上海市生活垃圾管理条例》推进全程分类体系建设实施意见的通知](http://www.shanghai.gov.cn/nw2/nw2314/nw2319/nw12344/u26aw58275.html)

