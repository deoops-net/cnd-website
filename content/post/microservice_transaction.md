---
title: "微服务中的事务管理"
date: 2019-06-05T17:26:18+08:00
draft: false
---

原文链接：[https://medium.com/@walkingtreetech/transaction-management-in-microservices-ab09b0cb803b](https://medium.com/@walkingtreetech/transaction-management-in-microservices-ab09b0cb803b)

![](https://cdn-images-1.medium.com/max/1600/0*xI-Pvkw9fxW3a_kc.png)

我们知道如果没有**事务**将不会有任何的实时系统。事务可以是资金转移，电子邮件发送，下订单，账单支付等。简单来说，事务是一个工作单元，任何需要持久数据到一个特定状态的业务应用都需要执行这个工作单元，但每个工作单元应该完全提交或完全回滚以确保数据完整性。

作为本博客的一部分，我将讨论在分布式微服务架构中管理事务的不同方法。我还将介绍与单体应用相比，微服务中事务管理的不同之处。

## 单体应用与微服务
单体应用在处理事务时主要依赖于ACID属性。单体应用的最大优势是管理事务于单个通用数据库服务器。事务可以在数据库级别启动，并可以根据事务的最终结果提交或回滚。这种启动事务，执行操作以及持久化或非持久化数据的方式更容易开发。然而，这种优势在运行大数据量生产应用时将会成为严峻挑战。一个关键表的简单锁定可能导致灾难性的结果，例如整个应用程序的不可用性。

微服务指南强烈建议您使用单一存储库原则（SRP），**这意味着每个微服务维护自己的数据库，其他服务不应直接访问其他服务的数据库**。因为没有直接和简单的方法来跨多个数据库维护ACID原则，这才是微服务中事务管理的真正挑战。

## SRP的实用方法
尽管微服务指南强烈建议您为每个微服务使用单独的数据库服务器，但作为设计人员，我们在微服务开发的早期阶段就出于实际原因采取了一些妥协。

以下是实施微服务但有一定妥协的方法：

* 在单个数据库中为服务维护一组特定的表，请为每个表保留前缀或后缀以指示它所属的微服务。不要在微服务的表之间创建任何外键约束。需要的时候移除对应的微服务的表。
* 为每个微服务创建对应的数据库表字段(scheme)，做到能够从名字就能对应相关的微服务。

但在上述两种情况下，不要让两个为服务之间交叉访问彼此的数据库，如果一个微服务需要另一个为服务的数据，通过微服务接口获取。

![](https://cdn-images-1.medium.com/max/1600/0*89t0bii5zkTACGii.png)
![](https://cdn-images-1.medium.com/max/1600/0*_OTP3aFq_XDcJEu_.png)

在一些高要求的场景下，有可能会维护一个通用的推送数据库给许多微服务，用以减少网络延迟。针对此问题的建议解决方案是数据复制，而不是单个数据库服务器。如果我们选择数据丛集，我们可能无法实现即时一致性，但您需要的是确保数据的最终一致性。

## 处理微服务中的事务的方法
在一段时间内，微服务社区提出了跨微服务处理事务的不同方法。一些方法在设计层级另一些在编码层级。

以下是我们可用于管理事务的不同方法的列表。我们可以在给定的微服务环境中使用以下一种或所有这些方法。在给定的环境中，两个微服务可以使用一种方法，而另一种可以遵循不同的方法进行事务管理。

* 避免跨微服务的事务
* 两阶段提交协议
* XA标准
* REST-AT标准草案
* 最终的一致性和补偿

## 避免跨微服务的事务
我们以twitter应用为例

假设如果Twitter为用户配置文件信息和推文信息维护在两个不同的微服务，那么如果想要显示用户页面上的最后一条推文日期时间，每当用户在Users表中推文发送任何新推文时就要存储/更新推文的日期和时间，所以我们需要在推文和用户信息微服务中维护分布式事务。

关注我们：
https://www.facebook.com/walkingtreetech/

https://www.linkedin.com/company/walking-tree-Technologies

https://twitter.com/walkingtreetech

https://www.youtube.com/channel/UCH5y9upqT2M7uWwgRWjCWBg

另一种方法是通过向推文微服务发出单独的请求以获取最新推文的日期时间并动态显示获取到最后一条推文的日期，这样我们就可以避免在用户表中存储时间而实现跨微服务的事务。

该方法主要在设计层面解决事务管理挑战。

## 两阶段提交协议
该机制最初是为分布式系统设计的。作为微服务架构本质上就继承了分布式系统，我们可以使用两阶段提交协议（或2PC）作为其中一种方法。分布式事务管理中的主要驱动程序是消息代理/事务协调器。

分布式事务包含两个步骤：
1. 准备阶段
2. 提交或回滚阶段

### 准备阶段：
此阶段的事务的所有参与者都将为提交做好准备，并通知事务协调器/消息代理他们已准备好完成事务

### 提交或回滚阶段：
在此阶段，事务协调器将向所有参与者发出其中一个命令，即提交或回滚。
2PC方法的主要问题是它与单个微服务上的操作时间相比有点慢，因为它必须协调服务之间的事务，即使所有微服务都在同一网络上，操作仍然会很慢。所以我们需要在为高需求服务实现这一点时要小心。

实施2PC时，您可以遵循下面描述的两种标准中的任何一种。

* **XA标准**
2PC规范之一即XA标准，用于在所有支持软件组件中实现分布式事务。所有符合JTA标准的应用服务都都是开箱即用的。分布式事务中的参与者可以是具有专用数据库的不同微服务。

但要使用此规范，微服务必须部署在单个JTA平台中，所以不总是可以在微服务架构中使用。

* **REST-AT标准草案**
REST-AT也是标准之一，RedHat仍处于开发它，尚未退出草案，但WildFly应用服务目前开箱即可支持此标准。

通过使用此标准，应用程序服务器充当事务协调器，具有用于处理分布式事务的特定REST API。

要在分布式事务中访问微服务的本地资源，我们仍然需要在单个JTA平台中部署这些资源。

## 最终一致性和补偿
当我们处理微服务中的分布式事务时，我们需要确保系统在未来的某个时间点最终应该是一致的。该模型不强制在微服务中使用ACID事务，但强制使用某种机制来确保一致性。

参与事务的每个服务都应自行负责以正确的事务状态更新用户，即使下一个连续的服务未能响应，那么他在启动时应该处理它们并确保所有计划的事务完成并且数据在系统是一致的。

资料来源：https：//walkingtree.tech/transaction-management-in-microservices/

