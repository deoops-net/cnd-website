---
title: "还在用虚拟机装Linux？Docker就够了！（下）"
date: 2019-06-30T21:10:12+08:00
draft: false
---

![](https://www.markeditor.com/file/get/0822f7509b7a8caa0e0140d4994655b6.jpg)

## 回顾

上一篇文章中我们一起动手做了一个ubuntu的基础镜像，并成功预安装了一个vim，接下来我们将更深度一些的定制我们的Linux环境。本篇诣在利用Dockerfile的丰富指令集和一些优化方法来构建更好的定制化Linux镜像。

## 一些常用的dotfile

我们日常会经常有很多的`dotfile`配置，如果我们把他构建到我们的Linux镜像中做成持久配置，岂不是爽歪歪，以后都不需要在找来找去，复制拷贝那些dotfile了。

上一篇中我们创建了一个项目目录my-awesome-linux，我们接着在这个目录下创建另一个目录叫dotfiles或者rcfiles，这个全凭你的喜好。现在我们以我们home目录下的.bashrc为例，假设我们已经配置了很多常用的环境变量，别名等，那我们现在就可以把这个bashrc文件构建到我们的镜像中去：


![](https://www.markeditor.com/file/get/f71c67c4e0a1e8e63edbd9ed09d069f0.png)

我们在Dockerfile添加了一行COPY命令，这个命令顾名思义就是把我们本地的文件或者目录复制到我们的镜像中去。通过这样的方式，我们构建好的镜像就拥有了一个我们早已天天使用维护的配置文件了，诸如此类，我们还可以添加很多常用的配置文件，这就不展开了。

## 创建用户

创建用户的命令还是很简单的，这里单独列出来:

一是想让读者对Linux有”用户”意识，不要总是root走天下，合理划分用户和权限可以让我们在大脑秀逗的时候避免很多不必要的麻烦，比如经常会念叨的梗：”从删库到跑路”，`rm -rf /` 等。

二是展示一个合理**隐藏敏感信息**的技巧，我们知道脚本化的创建用户命令`useradd tom -p $password`，这样一个RUN命令写在我们的Dockerfile中太不安全了。尤其是，如果在我们的生产环境中构建带鉴权信息的Dockerfile是**极其不安全的**，所以我们需要一些办法来合理的隐藏敏感信息。在Dockerfile中支持一个指令叫`ARG`，这个指令可以接受我们在docker build时传来的值，百闻不如一见，直接上Dockerfile：

![](https://www.markeditor.com/file/get/d47ab4bd83bd7f35434485a8755017c9.png)

这个Dockerfile中，我们添加了两行：

第一行我们遇到了一个新指令ARG，ARG命令告诉Docker从docker build中抓取 my\_user\_passwd这个指令。

在另一行RUN中我们通过一个变量引入标识${}来传递给命令。这样我们的Dockerfile中就不会暴露敏感信息了，而且我们也为useradd命令传递了密码。那么你可能会问密码怎么传递进来的呢？我们看一下命令你就清楚了：

```c
docker build --build-arg="my_user_passwd=admin" -t my-awesome-linux .
```

简单吧？我们在运行docker run的时候指定了密码，这个过程是不会泄漏的，除非有人摸进了你的本地主机，然后通过histroy查看！囧。

当然这个传递参数的方法还有很多其他玩法，这个就留给读者自行探索了😊

## 添加源码内部构建

有些时候，一些工具没有提供对应平台的预编译二进制可执行文件，我们就需要从源码构建我们的二进制了，我们都知道通常编译源码的时候会要执行很多次命令，而且可能中间会有一些错误发生，这样就导致构建这样一个需要编译源码的Dockerfile变得很麻烦也很乱，不易于维护。

当然有方法啦！

你还记得我们Dockerfile的第一行么？FROM指令，这个指令告诉Docker我们需要一个基础镜像，其实告诉你一个秘密，这个FROM指令可以同时写很多个，这种多个FROM的模式叫做**多阶段构建**，通俗理解也可以叫分步构建，分阶段构建。

> **多阶段构建可以让Docker在构建镜像的时候分成多个不同的任务去构建不同的临时镜像，然后最终汇总为一个持久镜像**

简单来说呢，就是分派不同的任务做不同的事，然后再汇总任务的结果。话不多说看看Dockerfile就明白了：

![](https://www.markeditor.com/file/get/69a4d6b5c35d88dbce620bb45e1f4859.png)

这次在Dockerfile中我们主要加入了一个指令`FROM`和`COPY`，和之前有一些区别的是我们多加了一些参数

在`FROM`中我们加入了as xxx 这样的语法，是不是很像写代码的时候的`import * as bar from foo `句式？其实这个指令的意思和import还真就差不都，我们把一个其他的镜像引入到当前环境做留作后面使用，而且最终的镜像不会包含这个引入镜像的完整镜像（如果包含那么体积太大了啊！），而唯一会留下的东东就是我们在下面的COPY指令中拷贝到当前镜像的文件。神奇吧！

通过这样的方式，我们就可以保持我们目标镜像的Dockerfile很清爽，把那些很复杂的部分拆分到各个小的镜像中去。是不是突然有了一种写代码的感觉？如果你有写代码的感觉，恭喜你，这个感觉是对的，无论是基础设施运维，还是PAAS管理这些都在向`* as code`的方向演进，这里就不展开咯，笔者推荐一本谷歌的线上免费书籍[Site Reliablity Engineering](http://landing.google.com/sre/workbook/toc/)。

## 总结

通过两篇相对简短的文章，笔者试图带你走过一个构建Docker Linux镜像完整路径，这里笔者着重想引起大家思考的是，一定要有一切皆代码的思想，无论你是运维还是开发者。很多笔者接触到的运维同学经常写shell脚本，python脚本，但是用过即走，很难形成体系，没有版本控制，最终同样的任务还需要重新写脚本。

我们应该拥抱版本控制，通过git持续修改，集成，精进我们的工具。

如果有任何问题，欢迎在评论区留言，提问😊



