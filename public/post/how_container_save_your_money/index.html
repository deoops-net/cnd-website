<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">

        
        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" integrity="sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB" crossorigin="anonymous">

        <link href="https://fonts.googleapis.com/css?family=Ubuntu|Ubuntu+Mono" rel="stylesheet"> 

        <title>容器、容器编排是如何为你的公司省钱的？</title>

        <link rel="stylesheet" href="/css/stylesheet.css">
    </head>
    <body>
      <div class="container-fluid">
        <nav class="navbar navbar-expand-md navbar-light">

          
          <span class="navbar-brand mb-0 h1"></span>

          <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle Navigation" name="button">
            <span class="navbar-toggler-icon"></span>
          </button>

          <div class="collapse navbar-collapse" id="navbarNavAltMarkup">
            <div class="navbar-nav">
              <a class="nav-item nav-link " href="/">Home</a>
              <a class="nav-item nav-link" href="https://github.com/dayuoba" target="_blank">GitHub</a>
              <a class="nav-item nav-link" href="https://gitlab.com/lifei" target="_blank">GitLab</a>
              <a class="nav-item nav-link " href="/about/">About</a>
            </div>
          </div>
        </nav>

        <section id="page-title">
          <h1><a href="/">云原生开发者</a></h1>
          <span id="author-name">
            <h6><a href="/about/">Dyu(dayuoba@gmail.com),Lee(longlee@gmail.com)</a></h6>
          </span>
        </section>


<div class="blog-post">
  <h1>容器、容器编排是如何为你的公司省钱的？</h1>
  <div class="blog-post-subheader">
    <time>13 May 2019</time>
  </div>
  <div class="blog-post-content">
    

<h1 id="容器-容器编排是如何为你的公司省钱的">容器、容器编排是如何为你的公司省钱的？</h1>

<p>翻译至：<a href="https://medium.com/kubernetes-tutorials/how-can-containers-and-kubernetes-save-you-money-fc66b0c94022">https://medium.com/kubernetes-tutorials/how-can-containers-and-kubernetes-save-you-money-fc66b0c94022</a></p>

<p>翻译：于洋
校稿：李飞
阅读时间：约15min</p>

<p>容器及容器编排技术正在<strong>大规模</strong>地改变<strong>多节点分布式</strong>环境中应用程序的开发部署及管理方式。</p>

<p>自2014年谷歌开源Kubernetes以来，很多有影响力的科技公司开始决定将其基于容器的工作负载迁移到k8s平台，从而促进其在社区中的日益普及和认可。</p>

<p>到了2019年，我们看到了一个广泛的共识，即由容器编排框架驱动的容器化平台使得应用程序的CI / CD，部署和管理更加高效和生产化。</p>

<p>然而，容器化的真正好处通常隐藏鲜有人知的复杂专业术语之下。</p>

<p>在本文中，我们将指导企业管理者和IT经理关于<strong>容器技术如何节约成本</strong>的潜力，并揭开容器编排复杂性的面纱。文章的结构安排如下。在第一部分中，我们将介绍容器体系结构以及容器对比虚拟机上的优势。在第二部分中，我们重点关注容器编排的经济效益，以及两家认识到容器化优势并成功采用容器化技术的IT公司的实际案例。那就开始吧！</p>

<h2 id="什么是容器-为什么它们如此高效">什么是容器，为什么它们如此高效？</h2>

<p>Linux容器化是一种允许将应用程序（）打包和隔离其整个运行时环境（例如，二进制文件，文件，依赖项）的技术。这使得容易在各种环境之间移动容器化应用程序，同时保留完整功能。听起来很熟悉？虚拟机（VM）是否提供相同的功能？答案是“是”和“否”。</p>

<p>简而言之，容器运行时是作为虚拟机（VM）镜像的替代方案而开发的。VM镜像比容器更重（即消耗更多资源），因为他们运行的是独立的完整的操作系统。并且，通常虚拟机启动较慢。相比之下，容器不需要将完整的操作系统镜像打包到其中即可工作。由于它们使用操作系统级虚拟化(译者注：linux内核提供的一系列进程隔离技术)而不是VM中的硬件级虚拟化，因此多个容器可以共享单个主机操作系统()。</p>

<p>容器通常包含主机文件系统的最小快照以及它们所需的必要依赖项（）。但这还不够。容器可以在需要时从主机操作系统请求其他资源和服务。由于这种独立的设计和灵活性，容器技术使得应用服务从底层基础设施中解耦并将它们与主机环境隔离，从而使它们具有很强的可移植性和环境无关性（）。</p>

<p>但这如何转化为成本节约的？其实并不难理解，让我们首先看一下下图，了解虚拟机技术和容器技术的不同之处。
<img src="DraggedImage.tiff" alt="" /></p>

<p>如您所见，在标准VM方案中（），在3个虚拟机中的托管3个应用程序的情况下将需要在服务器上运行三个同样的操作系统。请清楚一点，客户操作系统是由虚拟化管理软件管理的（），它将客户操作系统的指令转换为主机操作系统调用。在大多数情况下，客户操作系统与运行它的主机操作系统不同。</p>

<p>操作系统的虚拟化通常需要大量资源。这意味着运行我们的三个应用程序的VM将非常繁重并且将消耗大量内存，磁盘和CPU资源。</p>

<p>容器的方法有何不同？在容器世界中，所有3个应用程序都可以由容器引擎（例如，Docker）管理并共享同一个主机上的系统（）。</p>

<p>现在，您可以了解这里的基本优势：使用容器，可以在同一硬件上运行更多应用程序（），因为我们可以避免重复使用很重的系统镜像。因此，您可以使用单个主机，而不需要多个主机来虚拟化部署您的应用程序。听起来像一个巨大的成本节约？是的！</p>

<p>注意：人们普遍误解的认为Linux容器本质上是VM的迷你版本。这种误解主要可能来自于当我们查看Linux容器内部时，我们可以查看到很多Linux系统中的文件系统结构，设备和软件。但是，容器的文件系统及其运行时环境的内容不是完整的操作系统，而是容器工作所需的目标操作系统的一小（必要）部分。底层资源仍然由主机OS（）提供，而系统设备和软件由容器镜像提供。因此，主机Linux操作系统能够运行容器，即使它<strong>看起来像</strong>是完全不同的Linux发行版。</p>

<h2 id="容器这么好-我们还需要vm吗">容器这么好，我们还需要VM吗？</h2>

<p>重要的是要了解容器和VM在IT世界中都有其独特的地位。容器的到来并不意味着虚拟机已经过时，我们不再需要它们了。实际上仍然有许多场景您需要考虑使用VM。例如：</p>

<ul>
<li>对于需要所有操作系统资源和功能的应用程序，VM是更好的选择（）。</li>
<li>如果要管理各种各样的操作系统，VM会更好。虚拟机几乎可以运行任何操作系统，而容器可以锁定Linux发行版。</li>
<li>如果您希望灵活地运行多个应用程序()，则VM会更好。如果你想运行一个应用程序的多个副本（例如，数据库），你最好别用容器（）。</li>
</ul>

<p>用户还应该记住容器并不是完美的解决方案。容器中引用最广泛的问题是安全性（）。与流行的误解相反，容器并非完全独立。这意味着容器可以访问OS内核，所有设备，SELinux，Cgroup和所有系统文件。如果容器具有超级用户权限，则主机安全性可能会受到威胁。这意味着您无法以root身份在系统上运行随机容器应用程序。然而，最近，Kubernetes在向用户提供大量安全工具（SELinux，AppArmor，高度可配置的策略和网络选项等）方面做得非常出色，但是他们没有默认设置它们需要时间并进行适当的培训。</p>

<p>考虑到所有因素，容器有一定的局限性，但所有这些都是最终可以解决的。在接下来的内容中，我们继续分析当本节讨论的注意事项得到解决时立即出现的容器成本节约效益。</p>

<h2 id="容器设计多样性">容器设计多样性</h2>

<p>您可以利用各种容器设计模式来规定容器需要和消耗的资源数量。有三种基本模式可供选择：“临时”容器，容器操作系统和完整的操作系统容器。</p>

<p>流行的容器运行时（如Docker）允许创建非常轻便且快速的启动容器，称为“scratch”容器。它们基于“strach环境”，包括最少的资源和依赖性。默认情况下，临时容器无法访问SSH或更高级别的操作系统功能，这意味着它们受到一定限制。但是，如果您只需要一个超小型Linux内核和最少的功能来执行某些任务而无需访问主机整个操作系统，则可以使用临时容器。它们将大大降低您的基础架构成本。</p>

<p>如果您想要更多地接触主机操作系统，可以选择容器操作系统。这些容器映像提供了一个包管理器来安装依赖项。容器操作系统的一个很好的例子是官方Docker Hub存储库中提供的Alpine OS容器。这些容器也非常小：通常不超过5-8兆字节（例如，Docker Alpine OS映像的大小仅为5Mb）。但是，由于您可以安装依赖项，因此如果不对其进行检查，则容器OS的大小可以非常快地增加。</p>

<p>最后，像Docker这样的主要容器系统允许创建具有完整操作系统的容器。例如，您可以基于Ubuntu或任何其他Linux发行版创建容器。完整的操作系统容器将比容器操作系统和“临时”容器大得多，因此如果您想节省基础架构资源，它们就不太理想了。</p>

<p>利用这三种容器设计模式，您可以在部署中创建完美的容器组合，从而最大限度地减少不必要的基础架构成本。</p>

<h2 id="容器的其他节省成本的好处">容器的其他节省成本的好处</h2>

<p>至此，您已经知道容器体系结构如何确保比VM更有效地利用资源。然而，容器化成本节约的好处并不止于此。让我们列出其中最重要的一些：</p>

<ul>
<li><strong>容器是开源的，免费的</strong>。像Docker这样最流行的容器平台是开源的，任何人都可以免费使用（）。它们围绕开源Linux发行版和标准化技术构建，如cgroups，systemd，用户命名空间（namespace）以及其他支持容器隔离和操作系统级虚拟化的Linux概念和库。相比之下，即使像KVM这样的虚拟机平台是免费的，但像VMware这样的其他虚拟机平台在大规模使用时会花费相当多的钱（）。</li>
<li><strong>降低基础设施成本</strong>。我们已经看到容器可以比不可变的VM更轻量级和更快。容器中使用的操作系统级虚拟化允许在单个主机上安装运行多个容器。容器不需要运行大量重复的OS映像。即使实现非常简单，这些功能也可以节省两位数的资源（参见下面的案例研究）。</li>
<li><strong>降低配置和管理成本</strong>。在预容器时代，基础架构/运营团队将大部分时间花在配置服务器上，这是一项容易出错且繁琐的工作。然而，随着容器化的到来，游戏规则发生了变化。由于容器非常便携，是自包含的，并且所有依赖项都打包运行，因此它们对特定服务器环境和配置的依赖性较小。换句话说，它们不再与主机环境纠缠在一起。这意味着您可以节省配置具有依赖关系，环境变量，支持和系统库，网络等服务器的时间和资金。在开发/构建时，可以在容器内打包您在任何环境中运行应用程序所需的大部分内容而不是在部署时。</li>
<li><strong>开发人员和基础设施工程师之间更好的协同</strong>。此优势与前一点直接相关。容器技术使开发人员和基础架构团队之间的协作更和协， 开发人员可以构建应用程序并将其打包（镜像）到具有所有必需依赖项和设置的容器中，然后将容器镜像交给工程团队，该团队只需知道容器具有的网络和存储要求。工程师不再需要手动安装所有这些依赖项并调整服务器以使应用程序正常工作。容器将简单地使用这些自包含设置和内部环境与主机内核通信并使用它所需的资源。这方面的好处很明显：更快的上线时间，更低的工程成本，以及专门从事非常狭窄任务的小型团队。</li>
<li><strong>维护成本低</strong>。由于其独立的设计，容器引入了开发，测试和生产环境的环境平等。换句话说，当您使用容器时，所有这些环境都是一致的。这意味着可以节省大量成本，因为较小的团队可以更加轻松地维护一致的环境。开设的支持票（）也较少，从而腾出了支持与客户建立更紧密关系的时间。</li>
</ul>

<h2 id="kubernetes的成本节约优势">Kubernetes的成本节约优势</h2>

<p>容器很棒，但它们只是“部署单元”，如果大规模运行它们应该得到有效管理。当您运行分布在多个主机上的多个容器时，手动更新和扩展是容易出错且非平凡的任务。如果没有自动化，大规模使用容器的公司就会面临更长的停机时间，更慢的更新周期以及开发，测试和生产环境之间日益扩大的差距的风险。意识到这些风险，大中型公司都在将容器编排纳入其应用程序管理中。Kubernetes（或K8s）被广泛认为是市场上最好的容器化管理平台之一。</p>

<p>Kubernetes是一个开源平台，用于大规模部署和管理容器化应用程序。它可以自动化容器化应用程序的部署，扩展，调度，更新和联网。该平台简化了将带有容器化应用程序的多个主机分组到由业务流程引擎管理的同类群集中。自2014年谷歌开源Kubernetes以来，许多公司和开发人员为该项目做出了贡献，与流行的云提供商，存储系统和网络基础设施等建立了数十个集成.Kubernetes得到了不断发展的生态系统和社区的支持，目前最流行的容器编排工具。</p>

<p>Kubernetes是一个成熟的平台，具有在公共，私有，混合云，多云和本地运行容器的所有功能，包括网络，对状态应用程序和各种存储系统的支持，DNS，服务发现和微服务如果您遵循最佳实践，您可以期望Kubernetes成为您业务中显著节省成本的组件。我们编制了一份Kubernetes可以实现的成本效益清单：</p>

<ul>
<li><strong>减少管理和运营负担</strong>。部署在Kubernetes集群中的应用程序维护起来成本很低。设置并正确配置群集后，您可以期望应用程序以极低的停机时间和出色的性能运行，而无需频繁的支持干预。如果您的公司不使用容器编排，则基础架构和操作团队通常必须在节点或pod()发生故障时手动修复问题。使用Kubernetes，您的应用程序不再需要支持和维护费用。Kubernetes的控制平面定期监控节点和pod的健康状况，通过启动新pod或将其重新安排到健康节点来实现未达到所需状态的干预。得益于Kubernetes的内部集群监控系统，支撑问题急剧减少，公司能够更好地分配运营时间，与客户建立更高的关系标准。Ops团队也可以更小，更高效。</li>
<li><strong>更快的部署时间</strong>。Kubernetes的声明性语法使您可以轻松指定所需的部署状态，并将其交给控制器进行部署和维护。Kubernetes采用底层容器技术，可确保快速提取镜像并启动应用程序。</li>
<li><strong>高效的资源管理</strong>。Kubernetes通过容器技术实现高效的资源管理模型。您可以在容器级别对CPU，RAM等资源进行限制。这些可以参数控制容器在其生命周期的任何时间的可用最小和最大资源量。通过设置各种请求/限制比率（），您可以创建各种类型的pod - best effort型，guaranteed型和burstable型 - 取决于您的应用程序的需求。因此，资源请求和限制可确保集群管理员完全控制集群中的资源利用率。此外，Kubernetes支持命名空间范围的资源管理（注意：命名空间可以描述为分配给特定用户的集群的虚拟区域（）。使用Kubernetes，您可以定义自动应用于容器的默认资源请求和限制，资源约束（最小和最大资源请求和限制）以及在给定命名空间中运行的所有容器的资源配额。借助所有这些功能，您可以确保群集始终具有用于运行应用程序的可用资源，并显着降低云基础架构成本。</li>
<li><strong>由于高可用性集群而减少流失</strong>。现代Web应用程序预计会一直在增长。任何停机都可能破坏信任和客户信心并导致客户流失。为了避免停机，Kubernetes在设计时考虑了高可用性要求。该平台附带这些功能，默认情况下可实现高可用性：</li>
<li>自动维护所需的状态（）。Kubernetes允许运行多个pod副本（冗余）并维护所需的应用程序实例数（所需状态）。因此，您始终可以期望您的应用程序启动并运行。</li>
<li>高效的集群领导选举制度（）。最近版本的Kubernetes确保如果当前主节点由于某种原因失败，则选择新的集群领导者。通过这种方式，Kubernetes始终保持主功能的完整性并确保集群服务的连续性。</li>
<li>应用程序的健康和就绪探测。Kubernetes允许集成各种探针，以检查您的应用是否健康，正常运行和提供流量。如果你的pod有问题，Kubernetes会产生<strong>事件</strong>对象（）。</li>
<li>节点健康检查。Kubernetes定期监视节点运行状况，如果节点出现故障，它会将运行在其上的pod重新安排到健康节点。</li>

<li><p>滚动更新。您可以在零停机时间内逐步更新应用程序的多个实例。Kubernetes将确保在新版本的应用程序启动之前不会删除旧版本的应用程序。</p></li>

<li><p><strong>通过自动缩放降低成本</strong>。Kubernetes附带了在水平pod自动缩放器（HPA）中实现的本机自动缩放功能。它允许上下缩放pod，具体取决于不断变化的应用程序负载（CPU）和流量或任何其他自定义指标。HPA在管理基础架构成本方面非常有用：通常，您不需要运行比应用程序服务的实时需求更多的应用程序实例。HPA将通过根据您提供的指标扩展复制控制器，部署或副本集中的pod数量来解决这个问题。我们的Supergiant Kubernetes-as-a-Service工具包进一步扩展了这种自动缩放功能。其基于机器学习和计算机资源实时分析的高效节省成本算法可确保您的应用程序消耗他们实际需要的确切数量的资源（CPU和内存）。Supergiant可以选择具有适当资源的节点，以便您的pod总是紧密包装，并且您不需要为未使用的资源付费。</p></li>
</ul>

<h2 id="需要更多证据吗">需要更多证据吗？</h2>

<p>许多公司都很欣赏使用Kubernetes进行容器化工作的巨大成本效益。让我们简要讨论一下公司的两个案例研究，这些案例研究将他们的工作量转移到容器和Kubernetes：Qbox和Pinterest。</p>

<h3 id="qbox">QBOX</h3>

<p>Qbox公司。提供托管Elasticsearch服务，可简化云提供商（例如AWS）的Elasticsearch集群的部署和管理。最初，该公司是单租户，每个ES节点都是AWS上自己的专用机器（它本身就是一个VM）。此方法基于手工挑选针对Elasticsearch优化的某些实例类型，并将其留给用户来配置在任何区域中的隔离VM上运行的单租户，多节点群集。Qbox为DevOps支持和监控的每计算小时价格添加了一个标记。但是，当公司发展到数千个集群时，Qbox AWS账单很快就会失控。除此之外，支撑部门开始将大部分时间用于替换死节点和回答支持工单。更糟糕的是，与使用相比，公司面临分配给集群的更多资源的问题。Qbox拥有数千台服务器，集体CPU利用率低于5％。在大规模部署时，虚拟机被证明是极其无效的。</p>

<p>面对资源使用效率低下，利润空间受限以及来自云托管的Elasticsearch提供商（谷歌和AWS）的激烈竞争的问题，Qbox决定采用基于Kubernetes，Docker和Supergiant的容器优先方法，该方法由公司管理其Kubernetes部署。向容器化架构的过渡值得付出努力。性能改善几乎立刻就出现了 通过Kubernetes和Supergiant，Qbox可以在单个主机上“打包”更多应用程序，从而更有效地利用其基础架构并降低云成本。</p>

<p>为了提供对资源共享的精细控制，同时避免“吵闹的邻居”问题，Qbox还利用了Kubernetes的资源控制。通过设置特定于容器的资源请求和限制，Qbox在其集群中实现了对资源利用率的更细粒度控制，并成功转移到更实用，高性能和经济高效的多租户形态。因此，Kubernetes解决了利用率和噪声邻居问题。虽然Qbox是多租户，但每个人都可以获得他们付费的资源而不受其他用户的干扰（他们甚至可以获得更多，因为只有CPU（不是RAM）限制，因此如果没有其他用户，他们可以在服务器上使用在超过他们支付的资源）。</p>

<p>Qbox过渡到Kubernetes诞生了Supergiant Kubernetes-as-a-Service平台，该平台最初由公司用于简化Kubernetes上容器的部署。作为Supergiant的主要组件，Qbox开发了一种降低成本的打包算法，可以有效地将容器打包到节点上，避免资源利用不足，并根据负载高效地启动新节点或删除旧节点。使用Supergiant使得Qbox基础架构占用率立即下降25％。总体而言，该公司节省了50％（每年约60万美元）。</p>

<h3 id="pinterest">Pinterest</h3>

<p>Pinterest是一个Web应用程序，它运行一个旨在发现和共享Web上信息的系统，主要使用图像，GIF和视频。Pinterest在2017年9月拥有2亿月活跃用户。</p>

<p>Pinterest在2015年面临的挑战是管理超过1000个微服务，多层基础架构和各种设置工具。早在2015年，公司部署流程如下所示。它有一个基本的亚马逊机器映像（AMI），带有操作系统，通用共享包和已安装的工具。对于某些服务，主要是大型和复杂服务，该公司还有一个基于AMI构建的服务特定AMI，并且其中包含所有服务依赖包。除此之外，该公司还使用了两个部署工具：Puppet用于配置cron作业，infra组件和Teletraan，用于部署生产服务代码和一些ML模型。</p>

<p>大规模使用这种架构导致了几个艰难的挑战：</p>

<p>工程师必须参与系统的每个部分。特别是，他们必须制作AMI版本并学习各种配置语言，部署工具和不同云环境的功能。
由于应用程序与其托管环境之间没有明确的分离，因此主机上的环境逐渐分散并导致操作问题。
为应对这些挑战，2016年初，Pinterest决定将其微服务转移到Docker容器，并选择Kubernetes作为编排系统。该决定的直接影响是：</p>

<ul>
<li>简化了各种软件和基础架构的部署和管理。</li>
<li>由于容器的轻量级特性以及使用Kubernetes自动部署的能力，缩短了构建时间。</li>
<li>在高峰时段回收了80％的硬件容量。例如，与之前的静态集群相比，该公司的Jenkins Kubernetes集群每天使用的实例小时数减少了30％。</li>
<li>通过自动调度，滚动更新以及成功使用Kubernetes平台的其他编排功能，提高了上线速度。</li>
</ul>

<h2 id="结论">结论</h2>

<p>正如证据所示，容器化和Kubernetes具有巨大的成本节约潜力，受到许多大公司的青睐。特别是，容器可以显着降低基础架构成本，因为它们比VM更轻，并且可以共享单个OS。</p>

<p>容器的其他好处包括更快的CI / CD管道，开发和工程团队之间更好的协调以及低维护成本。如果将Kubernetes添加到等式中，则可以通过自动调节，高效的集群级资源管理，滚动更新和高效的应用程序调度来节省更多。</p>

<p>借助容器化应用程序和容器编排，您可以节省两位数的成本，并提高开发，运营和支持团队的工作效率。</p>

<p>最初发布于<a href="https://supergiant.io。">https://supergiant.io。</a></p>

  </div>
</div>

      <footer>
        <hr>
        <small>
          &copy; 2019 Dyu(dayuoba@gmail.com),Lee(longlee@gmail.com).
          Powered by <a href="https://gohugo.io/" target="_blank">Hugo</a> using the <a href="https://github.com/arjunkrishnababu96/basics" target="_blank">Basics</a> theme.
        </small>
      </footer>
    </div> 

    
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js" integrity="sha384-smHYKdLADwkXOn1EmN1qk/HfnUcbVRZyYmZ4qpPea6sjB/pTJ0euyQp0Mk8ck+5T" crossorigin="anonymous"></script>
  </body>
</html>

